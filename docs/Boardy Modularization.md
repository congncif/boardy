# Boardy Modularization

## Criteria

When modularizing an application, each module must meet the following criteria:

* Declare public integrations (Configs) within a single entry point.
* Easily integrate/remove from the main application using one or a few lines of code.
* Feature modules must declare an Interface module (Interface Target) for other modules to interact with.

<p align="center">
  <img src="https://i.imgur.com/GPUuKl5.png" alt="Boardy modular"/>
</p>

## Launcher

Each Launcher represents an app (micro-app) responsible for initializing configurations and starting the entry points.

By default, the shared Launcher corresponds to the executable app. Additional Launcher instances can be created to function as independent micro-apps.

## IOInterface

**Boardy** is a `micro-service` architecture, it promotes flexibility, interchangeability, independent deployment. Data consistency might be a problem need to care. An approach, data between micro-services is transferable to primitive data types, things that every micro-service knows well. Output of micro-service A should be encoded to `Swift.Data`, after that the raw data will be passed to micro-service B, the micro-service then decodes data to expected pure object and make a decision to *reject* or *accept*. This approach is popular and easy to implement. But Swift appreciates type safety and compile time check. So encoding & decoding may cause data type mismatch or when a micro-service changes data, other services interacting with it are not aware of the changes at compile time and easily cause runtime errors, difficult to trace. Another approach is using `Shared Interface`. By that way, micro-service A defines its interface which contains `Input` type to other services call to A, `Output` type to other services handle callback and some template methods to interact with A type safety. The interface called `Input Output Interface` or `IOInterface` for short. 

A `IOInterface` contains 2 flies:

* `InOut.swift` where defines Input/ Output types and other data structures *(You should modify these to your expected types)*.
* `IOInterface.swift` is generated by template *(you shouldn't edit this file)*, it contains some extension methods to other services call using **Boardy**.


Each of micro-service has a `IOInterface`. **Boardy Modularization** provides templates to create `IOInterface` easily.

## ModulePlugin & LauncherPlugin

For a module to integrate into a Launcher, it must define a **ModulePlugin**:

* Declare the module identifier.
* Initialize dependencies and define the entry points to corresponding features (components).

Each application has a main component where all things integrated with each other. `Main Component` will soon become cumbersome and difficult to manage as the application expands. **Boardy** provides a plugin mechanism for the integration of micro-service modules. Using the plugin module, adding or replacing a module is extremely simple, make your application become scalable.

**Boardy Module Plugin** is a interface to enable extending `MainComponent`. By that way, `MainComponent` expose some  open functions then module plugins can use these functions to register services which they provide.

A `Module Plugin` looks like:

```swift
import Boardy
import Foundation
import Dashboard

struct DashboardModulePlugin: ModuleBuilderPlugin {
    /// Each service is equivalent to one entry point
    enum ServiceType {
        case `default`

        var identifier: BoardID {
            switch self {
            case .default:
                return .pubDashboard
            }
        }
    }

    func build(with identifier: Boardy.BoardID, sharedComponent _: any Boardy.SharedValueComponent, internalContinuousProducer: any Boardy.ActivatableBoardProducer) -> any Boardy.ActivatableBoard {
        DashboardBoard(identifier: identifier, builder: DashboardBuilder(), producer: internalContinuousProducer)
    }

    func internalContinuousRegistrations(producer: any Boardy.ActivatableBoardProducer) -> [Boardy.BoardRegistration] {
        // Registration 1.1 ...
        // Registration 1.2 ...
    }

    let service: DashboardModulePlugin.ServiceType

    var identifier: BoardID {
        service.identifier
    }
}
```

Declare a **URLOpenerPlugin** if the entry points need to be started via deep links.

```swift
struct DashboardURLOpenerPlugin: URLOpenerPathMatchingPlugin {
    func mainboard(_ mainboard: any Boardy.FlowMotherboard, openURLWithParameters parameters: [String: String]) {
        mainboard.serviceMap.modDashboard.ioDashboard.activation.activate()
    }

    var matchingPath: String {
        "/dashboard"
    }
}
```

>Note that, you need implement `AppDelegate` method to **Launcher** handle opening via URL:

```swift
func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
    !PluginLauncher.shared.open(url: url).isEmpty
}
```

The **LauncherPlugin** collects the plugins registered by modules to create a single-point installation into the Launcher.

```swift
public struct DashboardLauncherPlugin: LauncherPlugin {
    public init() { /**/ }

    public func prepareForLaunching(withOptions _: MainOptions) -> ModuleComponent {
        ModuleComponent(
            modulePlugins: [
                DashboardModulePlugin(service: .default),
            ],
            urlOpenerPlugins: [
                DashboardURLOpenerPlugin(),
            ]
        )
    }
}
```

Put all to **Launcher** then launch the app (in `AppDelegate`):

```swift
PluginLauncher.with(options: .default)
    .install(launcherPlugin: DashboardLauncherPlugin())
    .install(launcherPlugin: AuthenticationLauncherPlugin())
    .install(launcherPlugin: EmployeeManagementLauncherPlugin())
    .initialize()
    .launch(in: window!) { mainboard in
          mainboard.serviceMap.modDashboard.ioDashboard.activation.activate()
    }
```

⭐️ In addition to defining the entry point, **ModulePlugin** is the best place to allocate internal instances of your module and resolve dependencies to external services.

>Module Plugin will be integrated into the app through the `PluginLauncher`, which will be presented in the following section.

## Templates

For the purpose of increasing efficiency, **Boardy Modularization** provides a series of templates that make creating micro-services convenient and simple.

* [**Boardy Xcode templates**](https://github.com/congncif/module-template) for micro-service creation.

<p align="center">
  <img src="https://i.imgur.com/XjME39K.png" alt=""/>
</p>

* [**Boardy Modularization template**](https://github.com/ifsolution/module-structure-template) is [Cocoapods](https://cocoapods.org) template for module using **Boardy Module Plugin** creation. When you use this template for creating new module, you will get 2 `podspecs` corresponding to 2 modules, one is Interface only (IO module), one is implementation module.
	- **Interface Module** contains *IOInterface* only of *Implementation Module*
	- **Implementation Module** contains a *ModulePlugin*, a default `RootBoard` as module entrance and some extensions, placeholder classes.

>We chose **CocoaPods** for its stability and support for multiple configurations, as well as its ease of generating projects using Pod development. These aspects make it significantly more stable compared to **SPM** or **Tuist**.

<p align="center">
  <img src="https://i.imgur.com/hEgeQVD.png" alt="Example notifications module"/>
</p>

### Install templates

We provide some scripts to install these templates and some other tools.

* Clone [scripts repo](https://github.com/ifsolution/father-scripts.git) to your project root folder
```sh
git clone https://github.com/ifsolution/father-scripts.git
```
* Install **Boardy Xcode templates**
```sh
sh father-scripts/install-template.sh
```

* Create a new module use **Boardy Modularization template**
>If you using local development pods, please follow below steps
```sh
# 1. Create submodules folder to contain your submodules if needed
mkdir submodules
```
```sh
# 2. Create folder for your module
cd submodules
mkdir your-module
```
```sh
# 3. Create initial source code using template
cd your-module
sh ../../father-scripts/init-module.sh YourModuleName
```
```ruby
# 4. Add Your Module to Podfile
pod "YourModule", :path => "submodules/your-module"
pod "YourModuleIO", :path => "submodules/your-module"
```

```sh
# 5. Install pods
pod install
```

## Set up App Launcher

* Load all modules into `PluginLauncher` in `AppDelegate`
* Launch your app

```swift
@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        PluginLauncher.with(options: .default)
	    .install(launcherPlugin: DashboardLauncherPlugin())
	    .install(launcherPlugin: AuthenticationLauncherPlugin())
	    .install(launcherPlugin: EmployeeManagementLauncherPlugin())
	    .initialize()
	    .launch(in: window!) { mainboard in
	          mainboard.serviceMap.modDashboard.ioDashboard.activation.activate()
	    }

        return true
    }

    func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
        !PluginLauncher.shared.open(url: url).isEmpty
    }
}

```

>From Boardy with ♥️
